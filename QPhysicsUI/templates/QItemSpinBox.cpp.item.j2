/*
    Copyright (C) 2013, 2014, 2017 Remi Thebault
    All rights reserved.

    This program and its source code are distributed under the
    terms of the BSD-style license, that can be found in the
    License.txt file at project root.
*/

#include "Q{{item.titleName}}SpinBox.hpp"

#include "ph/Physics.hpp"

#include "QMenu"
#include "QMetaType"
#include "QContextMenuEvent"

#include <cassert>


static int _ = qRegisterMetaType<ph::{{item.titleName}}>("ph::{{item.titleName}}");


{% for unit in item.units %}
inline QString {{unit.name}}str()
{
    const auto strView = ph::{{item.titleName}}::allUnitsUtf16[{{ loop.index }}];
    return QString::fromUtf16(strView.data(), strView.size());
}
{% endfor %}


inline QString {{item.name}}UnitToString(Q{{item.titleName}}SpinBox::{{item.titleName}}Unit unit)
{
    switch (unit) {
    {% for unit in item.units %}
    case Q{{item.titleName}}SpinBox::{{unit.name}}:
        return {{unit.name}}str();
    {% endfor %}
    }

    assert(!"the passed unit is wrong");
    return "";
}


inline Q{{item.titleName}}SpinBox::{{item.titleName}}Unit {{item.name}}UnitFromString(QString s)
{
    {% for unit in item.units %}
    if (s == {{unit.name}}str()) return Q{{item.titleName}}SpinBox::{{unit.name}};
    {% endfor %}

    assert(!"the passed string is wrong");
    return Q{{item.titleName}}SpinBox::{{item.defaultUnit}};
}


inline double {{item.name}}UnitValue(ph::{{item.titleName}} {{item.name}}, Q{{item.titleName}}SpinBox::{{item.titleName}}Unit unit) {
    switch (unit) {
    {% for unit in item.units %}
    case Q{{item.titleName}}SpinBox::{{unit.name}}:
        return {{item.name}}.{{ unit.name }}();
    {% endfor %}
    }

    assert(!"the passed {{item.name}} is wrong");
    return 0.0;
}


inline ph::{{item.titleName}} unit{{item.titleName}}(double value, Q{{item.titleName}}SpinBox::{{item.titleName}}Unit unit) {
    switch (unit) {
    {% for unit in item.units %}
    case Q{{item.titleName}}SpinBox::{{unit.name}}:
        return ph::{{item.titleName}}::from{{unit.titleName}}(value);
    {% endfor %}
    }

    assert(!"the passed value is wrong");
    return ph::{{item.titleName}}();
}



Q{{item.titleName}}SpinBox::Q{{item.titleName}}SpinBox(QWidget *parent) :
    QDoubleSpinBox(parent),
    unit_({{item.defaultUnit}}),
    changeUnitFlag_(false)
{
    updateSuffix();

    QObject::connect(this, SIGNAL(valueChanged(double)),
                     this, SLOT(handleValueChange(double)));

    installEventFilter(this);
}

Q{{item.titleName}}SpinBox::~Q{{item.titleName}}SpinBox()
{}


ph::{{item.titleName}} Q{{item.titleName}}SpinBox::{{item.name}}() const
{
    return unit{{item.titleName}}(value(), unit());
}


void Q{{item.titleName}}SpinBox::set{{item.titleName}}(ph::{{item.titleName}} val)
{
    if (val != {{item.name}}() && val >= mini() && val <= maxi()) {
        setValue({{item.name}}UnitValue(val, unit()));
    }
}


ph::{{item.titleName}} Q{{item.titleName}}SpinBox::step() const
{
    return unit{{item.titleName}}(singleStep(), unit());
}


void Q{{item.titleName}}SpinBox::setStep(ph::{{item.titleName}} val)
{
    setSingleStep({{item.name}}UnitValue(val, unit()));
}


ph::{{item.titleName}} Q{{item.titleName}}SpinBox::mini() const
{
    return unit{{item.titleName}}(minimum(), unit());
}


void Q{{item.titleName}}SpinBox::setMini(ph::{{item.titleName}} val)
{
    setMinimum({{item.name}}UnitValue(val, unit()));
}


ph::{{item.titleName}} Q{{item.titleName}}SpinBox::maxi() const
{
    return unit{{item.titleName}}(maximum(), unit());
}


void Q{{item.titleName}}SpinBox::setMaxi(ph::{{item.titleName}} val)
{
    setMaximum({{item.name}}UnitValue(val, unit()));
}


void Q{{item.titleName}}SpinBox::updateSuffix()
{
    setSuffix(QString(" %1").arg({{item.name}}UnitToString(unit_)));
}


void Q{{item.titleName}}SpinBox::handleValueChange(double value)
{
    if (changeUnitFlag_) return;
    emit {{item.name}}Changed(unit{{item.titleName}}(value, unit()));
}


void Q{{item.titleName}}SpinBox::setUnit({{item.titleName}}Unit unit, bool trackBounds)
{
    if (unit != unit_) {
        if (trackBounds) {
            ph::{{item.titleName}} t = {{item.name}}();
            ph::{{item.titleName}} stp = step();
            ph::{{item.titleName}} min = mini();
            ph::{{item.titleName}} max = maxi();

            changeUnitFlag_ = true;

            unit_ = unit;
            updateSuffix();

            setMaxi(max);
            setMini(min);
            setStep(stp);
            set{{item.titleName}}(t);

            changeUnitFlag_ = false;
        }
        else {
            changeUnitFlag_ = true;

            unit_ = unit;
            updateSuffix();

            changeUnitFlag_ = false;
        }
    }
}


void Q{{item.titleName}}SpinBox::handleCustomMenu(const QPoint &globalPos)
{
    QMenu menu;

    {% for unit in item.units %}
    menu.addAction({{item.name}}UnitToString({{unit.name}}));
    {% endfor %}

    QAction *a = menu.exec(globalPos);

    if (a) {
        setUnit({{item.name}}UnitFromString(a->text()), true);
    }
}


bool Q{{item.titleName}}SpinBox::eventFilter(QObject *obj, QEvent *event)
{
    if (obj == this) {
        if (event->type() == QEvent::ContextMenu) {
            QContextMenuEvent *mEv = static_cast<QContextMenuEvent*>(event);
            if (mEv->modifiers() & Qt::ControlModifier) {
                handleCustomMenu(mEv->globalPos());
                return true;
            }
        }
        return false;
    }
    else {
        return QDoubleSpinBox::eventFilter(obj, event);
    }
}
