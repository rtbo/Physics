/*
    Copyright (C) 2013-2014, 2017 Remi Thebault
    All rights reserved.

    This program and its source code are distributed under the
    terms of the BSD-style license, that can be found in the
    License.txt file at project root.
*/

#ifndef PHYSICS_{{item.name|upper}}_HPP
#define PHYSICS_{{item.name|upper}}_HPP

#include "ph/Zero.hpp"

#ifdef PHYSICS_HAVE_QT_CORE
#include <QMetaType>
#endif

#include <array>
#include <cstddef>
#include <limits>
#include <string_view>

namespace ph {

    class {{item.titleName}}
    {
        double {{item.defaultUnit}}_;

        explicit constexpr {{item.titleName}}(double {{item.defaultUnit}}) :
            {{item.defaultUnit}}_{{ '{' + item.defaultUnit + '}' }}
        {}

    public:

        enum class Unit
        {
{% for unit in item.units %}
            {{unit.name}},
{% endfor %}
        };

        static constexpr std::size_t numUnits = {{ item.units | length }};

        static constexpr std::array<Unit, numUnits> allUnits = {
{% for unit in item.units %}
            Unit::{{unit.name}},
{% endfor %}
        };

        static constexpr std::array<std::u16string_view, numUnits> allUnitsUtf16 = {
{% for unit in item.units %}
            std::u16string_view{ u"{{ unit.wcharSeq }}", {{ unit.wcharSeqLen }} },
{% endfor %}
        };

        static constexpr std::u16string_view unitUtf16(const Unit unit)
        {
            return allUnitsUtf16 [ static_cast<int>(unit) ];
        }

        constexpr {{item.titleName}}(const Unit unit, const double value) :
            {{item.defaultUnit}}_{0.0}
        {
            switch(unit)
            {
{% for unit in item.units %}
            case Unit::{{unit.name}}:
                {{item.defaultUnit}}_ = ( value + {{unit.offsetToDefault}} ) * {{unit.factorToDefault}};
                break;
{% endfor %}
            }
        }

{%for unit in item.units%}
        static constexpr {{item.titleName}} from{{unit.titleName}}(const double value)
        {
            return {{item.titleName}} {
                ( value + {{unit.offsetToDefault}} ) * {{unit.factorToDefault}}
            };
        }

{%endfor%}
        constexpr {{item.titleName}}() :
            {{item.defaultUnit}}_(0.0)
        {}

        constexpr {{item.titleName}}(const {{item.titleName}}& other) :
            {{item.defaultUnit}}_(other.{{item.defaultUnit}}_)
        {}

        constexpr {{item.titleName}}(const zero_t&) :
            {{item.defaultUnit}}_(0.0)
        {}

        {{item.titleName}}& operator=(const {{item.titleName}}& other)
        {
            {{item.defaultUnit}}_ = other.{{item.defaultUnit}}();
            return *this;
        }

        {{item.titleName}}& operator=(const zero_t&)
        {
            {{item.defaultUnit}}_ = 0.0;
            return *this;
        }

        constexpr double to(const Unit unit) const
        {
            switch(unit) {
{% for unit in item.units %}
            case Unit::{{unit.name}}:
                return ( {{item.defaultUnit}}_ / {{unit.factorToDefault}} ) - {{unit.offsetToDefault}};
{% endfor %}
            }
            return std::numeric_limits<double>::quiet_NaN();
        }

{%for unit in item.units%}
        constexpr double {{unit.name}}() const
        {
            return ( {{item.defaultUnit}}_ / {{unit.factorToDefault}} ) - {{unit.offsetToDefault}};
        }

{%endfor%}

        {{item.titleName}}& operator+=({{item.titleName}} rhs)
        {
            {{item.defaultUnit}}_ += rhs.{{item.defaultUnit}}();
            return *this;
        }

        {{item.titleName}}& operator-=({{item.titleName}} rhs)
        {
            {{item.defaultUnit}}_ -= rhs.{{item.defaultUnit}}();
            return *this;
        }

        {{item.titleName}}& operator*=(double rhs)
        {
            {{item.defaultUnit}}_ *= rhs;
            return *this;
        }

        {{item.titleName}}& operator/=(double rhs)
        {
            {{item.defaultUnit}}_ /= rhs;
            return *this;
        }

    };



    constexpr {{item.titleName}} operator+({{item.titleName}} lhs, {{item.titleName}} rhs)
    {
        return {{item.titleName}}::from{{item.titleDefaultUnit}}(lhs.{{item.defaultUnit}}() + rhs.{{item.defaultUnit}}());
    }

    constexpr {{item.titleName}} operator-({{item.titleName}} lhs, {{item.titleName}} rhs)
    {
        return {{item.titleName}}::from{{item.titleDefaultUnit}}(lhs.{{item.defaultUnit}}() - rhs.{{item.defaultUnit}}());
    }

    constexpr {{item.titleName}} operator-({{item.titleName}} p)
    {
        return {{item.titleName}}::from{{item.titleDefaultUnit}}(-p.{{item.defaultUnit}}());
    }

    constexpr {{item.titleName}} operator*({{item.titleName}} lhs, double rhs)
    {
        return {{item.titleName}}::from{{item.titleDefaultUnit}}(lhs.{{item.defaultUnit}}() * rhs);
    }

    constexpr {{item.titleName}} operator*(double lhs, {{item.titleName}} rhs)
    {
        return rhs * lhs;
    }

    constexpr {{item.titleName}} operator/({{item.titleName}} lhs, double rhs)
    {
        return {{item.titleName}}::from{{item.titleDefaultUnit}}(lhs.{{item.defaultUnit}}() / rhs);
    }

    constexpr double operator/({{item.titleName}} lhs, {{item.titleName}} rhs)
    {
        return lhs.{{item.defaultUnit}}() / rhs.{{item.defaultUnit}}();
    }


    constexpr bool operator==({{item.titleName}} lhs, {{item.titleName}} rhs)
    {
        return lhs.{{item.defaultUnit}}() == rhs.{{item.defaultUnit}}();
    }

    constexpr bool operator!=({{item.titleName}} lhs, {{item.titleName}} rhs)
    {
        return lhs.{{item.defaultUnit}}() != rhs.{{item.defaultUnit}}();
    }

    constexpr bool operator>=({{item.titleName}} lhs, {{item.titleName}} rhs)
    {
        return lhs.{{item.defaultUnit}}() >= rhs.{{item.defaultUnit}}();
    }

    constexpr bool operator<=({{item.titleName}} lhs, {{item.titleName}} rhs)
    {
        return lhs.{{item.defaultUnit}}() <= rhs.{{item.defaultUnit}}();
    }

    constexpr bool operator>({{item.titleName}} lhs, {{item.titleName}} rhs)
    {
        return lhs.{{item.defaultUnit}}() > rhs.{{item.defaultUnit}}();
    }

    constexpr bool operator<({{item.titleName}} lhs, {{item.titleName}} rhs)
    {
        return lhs.{{item.defaultUnit}}() < rhs.{{item.defaultUnit}}();
    }



    constexpr bool operator==({{item.titleName}} lhs, zero_t)
    {
        return lhs.{{item.defaultUnit}}() == 0.0;
    }

    constexpr bool operator==(zero_t, {{item.titleName}} rhs)
    {
        return rhs.{{item.defaultUnit}}() == 0.0;
    }


    constexpr bool operator!=({{item.titleName}} lhs, zero_t)
    {
        return lhs.{{item.defaultUnit}}() != 0.0;
    }

    constexpr bool operator!=(zero_t, {{item.titleName}} rhs)
    {
        return rhs.{{item.defaultUnit}}() != 0.0;
    }


    constexpr bool operator<({{item.titleName}} lhs, zero_t)
    {
        return lhs.{{item.defaultUnit}}() < 0.0;
    }

    constexpr bool operator<(zero_t, {{item.titleName}} rhs)
    {
        return 0.0 < rhs.{{item.defaultUnit}}();
    }


    constexpr bool operator>({{item.titleName}} lhs, zero_t)
    {
        return lhs.{{item.defaultUnit}}() > 0.0;
    }

    constexpr bool operator>(zero_t, {{item.titleName}} rhs)
    {
        return 0.0 > rhs.{{item.defaultUnit}}();
    }


    constexpr bool operator<=({{item.titleName}} lhs, zero_t)
    {
        return lhs.{{item.defaultUnit}}() <= 0.0;
    }

    constexpr bool operator<=(zero_t, {{item.titleName}} rhs)
    {
        return 0.0 <= rhs.{{item.defaultUnit}}();
    }


    constexpr bool operator>=({{item.titleName}} lhs, zero_t)
    {
        return lhs.{{item.defaultUnit}}() >= 0.0;
    }

    constexpr bool operator>=(zero_t, {{item.titleName}} rhs)
    {
        return 0.0 >= rhs.{{item.defaultUnit}}();
    }

}

#ifdef PHYSICS_HAVE_QT_CORE
    Q_DECLARE_METATYPE(ph::{{item.titleName}})
#endif

#endif // PHYSICS_{{item.name|upper}}_HPP
